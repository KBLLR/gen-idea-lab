# Analysis of `gen-idea-lab` `src` Folder and 2025 React Best-Practice Guidelines

---

## 1. Current Repository Structure

The `gen-idea-lab` repository contains a `src` folder with a **modular architecture**. The `main.jsx` file creates a React root and renders `App`, which serves as the entry point for multiple tools:

- Chat
- Idea Lab
- Image Booth
- Archives
- Workflows
- Planner
- Calendar AI
- Empathy Lab
- Gesture Lab

Within `App`, the currently active app is read from a **central store**, and the left and right columns render components based on this value ([source](https://raw.githubusercontent.com)). For example:

- If the active app is **chat**, the sidebar shows `ChatSidebar` and the right column renders `Chat`.
- For **ideaLab**, the sidebar shows `ModuleSelector`, and the right panel may show `ModuleKnowledgeSection` or `ModuleViewer` depending on state ([source](https://raw.githubusercontent.com)).
- Other apps (`imageBooth`, `archiva`, `workflows`, `planner`, `calendarAI`, `empathyLab`, `gestureLab`) each have their own sidebar and main components ([source](https://raw.githubusercontent.com)).

The app also conditionally displays **global features** such as:
- `GlassDock`
- `CommandPalette`
- `SettingsModal`
- `SystemInfoModal`
- `UserBar`
([source](https://raw.githubusercontent.com))

### Observed `src` Folder Structure (via GitHub)

| Folder/File        | Purpose |
|--------------------|---------|
| **`components`**   | Top-level UI components. Subfolders correspond to tools (`empathy`, `gesture`, `glassdock`, `planner`, `sidebar`, `stellar`) and generic UI (`ui`). Most components include `.test.js` and `.stories.jsx` files, indicating integrated **testing** and **Storybook** usage. The `App` component imports and conditionally renders these based on active app state. ([source](https://raw.githubusercontent.com)) |
| **`data`**         | Holds static data files (e.g., `modules-code-university.json`), loaded by library functions. |
| **`hooks`**        | Reusable custom hooks. Some component-specific hooks live within their component folders, following the **co-location principle** ([Robin Wieruch](https://robinwieruch.de)). |
| **`lib`**          | Shared utilities: actions, assistant logic, a **Zustand store** (`store.js`), design tokens, and modules. `modules.js` imports a large JSON dataset and groups modules by discipline for the Idea Lab tool. |
| **`pages`**        | Static HTML pages (e.g., `404.html`, `privacy.html`, `terms.html`). |
| **`stories`**      | Storybook stories not tied to a single component (e.g., `Tokens.stories.jsx` for design tokens). |
| **`styles`**       | Global CSS files. Component-scoped styles are imported directly within components. |
| **`index.css` & `main.jsx`** | Entry-point styles and React root renderer. |

### Observations

- **Modular Multi-App Architecture**:
  The app hosts several distinct tools, each with its own sidebar and main view. Zustand manages global state (active app, column widths, auth status). However, all tools live under `components` with **no clear boundaries**—suggesting they are not yet independent packages.

- **Design System Presence**:
  The existence of `Tokens.stories.jsx` and a `styles` folder indicates intent to build a design system. Many components use CSS modules or `clsx`, but **no explicit design tokens or theming utilities** are visible at the top level. Style co-location could be improved.

- **Storybook Usage**:
  Most components include `.stories.jsx` files, confirming Storybook as a **component workshop and documentation tool**. A top-level `stories/` folder likely holds shared stories. The Storybook config (e.g., `.storybook/main.js`) is probably in the project root (not in `src`).

---

## 2. Modern React Architecture for Interconnected Apps (2025)

### 2.1 Micro-Frontend and Modular Architecture

The current monolithic codebase can evolve toward a **micro-frontend architecture**, which supports:
- Team autonomy
- Independent deployment
- Technology diversity
- Scalability

> *Source: [The Expert Developer, 2025](https://the-expert-developer.medium.com)*

#### Recommendations:
- **Split each tool into its own package** (e.g., via **Turborepo**, **Nx**, or **Yarn workspaces**). Each exports a React micro-app.
- Create a **host/shell application** (refactor `App`) that:
  - Handles global concerns (auth, user prefs, design tokens)
  - Lazily loads micro-apps via `React.lazy` + `Suspense` or **Module Federation**
- **Define a communication contract**:
  Micro-apps should **not import each other directly**. Instead, use:
  - Shared store (e.g., Zustand in a shared package)
  - Event-based communication
- **Isolate runtimes**:
  Use **Webpack 5 Module Federation**, **Vite’s `import.meta.glob`**, or **esbuild dynamic imports** to avoid dependency conflicts.

### 2.2 Shared State Management

- Use a **global store** (e.g., Zustand) for:
  - Authentication
  - User preferences
  - App navigation
- Each micro-app manages its **own local state**.
- Use **selectors** to minimize re-renders and avoid exposing the full store to every component.

### 2.3 Routing and Navigation

- Replace manual `activeApp` switching with **React Router** or **TanStack Router**.
- Define **nested routes** per micro-app (e.g., `/archiva/:entryId`).
- The host handles **lazy loading** and **fallback states**.

### 2.4 Performance and Code-Splitting

- **Dynamically import** tools and non-critical components (e.g., modals, editors).
- Consider **SSR with streaming** for faster initial loads, especially with micro-frontends.

### 2.5 Testing and CI

- Each micro-app should have:
  - Unit/integration tests (**Jest + React Testing Library**)
  - E2E tests (**Cypress** or **Playwright**)
- In a monorepo, ensure **isolated test runs** with shared mocks/utilities.

---

## 3. React Folder Structure Best Practices (2025)

Based on **[Robin Wieruch’s guidelines](https://robinwieruch.de)**:
- Start simple; **co-locate related files** (component, styles, test, story).
- Extract reusable hooks only when needed.
- Avoid deep nesting; shared features shouldn’t be duplicated.

### Recommended Structure for `gen-idea-lab`:

```plaintext
src/
├── apps/
│   ├── chat/
│   │   ├── components/
│   │   ├── hooks/
│   │   ├── pages/
│   │   ├── styles/
│   │   └── index.tsx          # exports ChatApp
│   ├── idea-lab/
│   ├── image-booth/
│   └── ...                    # one folder per tool
├── design-system/
│   ├── components/            # Button, Input, Card, etc.
│   ├── hooks/                 # useTheme, useResponsive
│   ├── tokens/                # color.js, spacing.js, typography.js
│   ├── styles/
│   ├── stories/
│   └── index.tsx
├── shared/
│   ├── lib/                   # API clients, store, utils
│   ├── hooks/                 # cross-app reusable hooks
│   └── types/
├── index.tsx                  # host app entry
└── routes.tsx
```

#### Key Principles:
- ✅ **Group by feature/micro-app** under `apps/`
- ✅ **Design system as a first-class package**
- ✅ **Shared utilities** in `shared/` (not cross-imported between apps)
- ✅ **Shallow nesting** (max 2 levels inside apps)
- ✅ **Co-locate** component files (`.jsx`, `.css`, `.test.js`, `.stories.jsx`)
- ✅ **Separate hooks**: app-specific inside `apps/`, reusable in `shared/hooks/`

---

## 4. Design System Best Practices

A **design system** ensures UI consistency and accelerates development ([Angular Minds, 2024/2025](https://angularminds.com)).

### Core Practices:
1. **Define design tokens**
   - Colors, typography, spacing, radii, elevation
   - Store as **platform-agnostic** JSON/JS modules
   - Example: IBM Carbon uses tokens systematically ([source](https://angularminds.com))

2. **Build primitive components**
   - Start with `Button`, `Input`, `Card`, `Modal`
   - Support theming, states (hover/focus/disabled)
   - Use `forwardRef` and prop composition

3. **Ensure accessibility & responsiveness**
   - Follow **WCAG**
   - Use semantic HTML + ARIA
   - Keyboard navigable, responsive across breakpoints

4. **Document with Storybook**
   - Use **MDX** + `@storybook/addon-docs`
   - Show props, variants, usage guidelines

5. **Version and govern**
   - Semantic versioning
   - Changelog + designer/engineer review process

6. **Test rigorously**
   - Unit tests: **Jest + React Testing Library**
   - Visual regression: **Chromatic** or **Playwright**
   - Essential tools: Storybook, styled-components, Chromatic ([source](https://angularminds.com))

### Applying to `gen-idea-lab`:
- **Centralize tokens** in `design-system/tokens/`
- **Extract repeated UI** (buttons, modals, panels) into `design-system/components/`
- **Move `GlassDock`** into design system
- **Enhance theming** to support light/dark modes via tokens or CSS variables

---

## 5. Storybook Best Practices (2025)

### Recommendations:
- **Configure essential addons**:
  - `@storybook/addon-docs` → MDX documentation
  - `@storybook/addon-controls` → interactive props
  - `@storybook/addon-a11y` → accessibility checks
  - `@storybook/addon-viewport` → responsive testing
  - `@storybook/addon-design-assets` → Figma links
- **Use `.stories.mdx`** for rich documentation (mix Markdown + JSX)
- **Mirror folder structure**: Load stories from `apps/` and `design-system/`
- **Create micro-app stories**: Demo full apps (e.g., `ChatApp`) to test integration
- **Automate visual regression** with **Chromatic** ([source](https://angularminds.com))
- **Deploy Storybook** (e.g., Vercel/Netlify) for stakeholder feedback
- **Use Storybook Composition** to merge stories from multiple packages in a monorepo

---

## 6. Recommendations and Next Steps

1. **Adopt a monorepo with modular packages**
   - Move each tool into `apps/`
   - Keep a **host app** at root
   - Use **Yarn workspaces** or **Turborepo**
   → Enables micro-frontend benefits ([source](https://the-expert-developer.medium.com))

2. **Establish a formal design system**
   - Create `design-system/` package
   - Centralize tokens, primitives, docs
   - Support theming (light/dark) ([source](https://angularminds.com))

3. **Refine folder structure**
   - Follow Wieruch: shallow, co-located, reusable hooks in `shared/` ([source](https://robinwieruch.de))

4. **Enhance Storybook**
   - Cover all component states
   - Enable addons, visual regression, composition
   - Publish for non-dev feedback ([source](https://angularminds.com))

5. **Implement state & communication contracts**
   - Define cross-app events (e.g., `userLoggedIn`, `themeChanged`)
   - Use shared store or event bus — **no direct state manipulation**

6. **Refactor incrementally**
   - Start with design system extraction
   - Migrate one simple app (e.g., `EmpathyLab`) to its own package
   - Evaluate **Module Federation** if needed

---

> ✅ **By restructuring into micro-apps, formalizing a design system, and enhancing Storybook, `gen-idea-lab` can scale sustainably while maintaining a consistent, high-quality user experience across all interconnected tools.**

---
## Continuation refactor plan

### Front end (main.jsx and App.jsx):

Keep main.jsx minimal but replace the direct App import with a router-based entry point. The host app should use React Router to map high-level routes (e.g., /chat, /planner) to lazily imported micro‑app components.

Extract global concerns (theme, authentication, command palette, GlassDock) into their own context providers or higher-order components and wrap the router in them.

Move each tool (chat, planner, empathy lab, etc.) into its own package under an apps/ directory. Each package will export a root component and its own routes; the host simply mounts these via the router.

Shared state (authentication, theme, active app) should live in a separate core-store package, so micro‑apps can subscribe without importing each other.

### Back end (server.js):

Break the single server.js into domain‑specific modules. For example, create routes/auth.js, routes/university.js, routes/modules.js, routes/empathyLab.js, etc. Each should export an express.Router() instance encapsulating its endpoints.

Extract business logic from route handlers into service functions under services/. This isolates database access, external API calls (e.g., Google and Ollama), and token management, making them easier to test.

Centralise middleware such as CORS handling, cookie parsing, and authentication checks in a middleware/ folder. Apply them selectively by router instead of globally when possible.

If certain functionalities (e.g., empathy lab sessions or image generation) have different scaling or security requirements, consider splitting them into separate microservices with their own Express servers. The current server can act as a gateway.

Introduce configuration files (e.g., config/index.js) to encapsulate environment variable logic like base URLs and port selection, instead of inlining it throughout server.js.
