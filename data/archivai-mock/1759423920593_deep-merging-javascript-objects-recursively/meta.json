{
  "id": "1759423920593_deep-merging-javascript-objects-recursively",
  "templateKey": "Code_Notebook",
  "templateName": "Code Notebook",
  "title": "Deep Merging JavaScript Objects Recursively",
  "createdAt": "2025-10-02T16:52:00.593Z",
  "meta": {
    "workflow_id": "mock_1759423866238",
    "run_id": "run_1759423866238"
  },
  "values": {
    "date": "2025-10-02",
    "title": "Deep Merging JavaScript Objects Recursively",
    "problem_context": "Often, when dealing with configuration objects, state management in UI libraries (like React or Vue), or combining user-provided options with default settings, a simple shallow merge isn't sufficient. Methods like `Object.assign()` or the spread operator (`{...obj1, ...obj2}`) only merge properties at the top level. If there are nested objects, they are overwritten entirely rather than merged.\n\nThis snippet addresses the need for a **deep merge**, where nested objects and arrays are also merged recursively, preserving existing keys and adding new ones, without losing data from either source object. This is particularly useful for creating robust, customizable systems where defaults can be overridden incrementally.",
    "code_snippet": "/**\n * Recursively merges two or more objects deeply.\n * Properties in later objects will overwrite properties in earlier ones.\n * Handles nested objects and arrays. Arrays are concatenated.\n *\n * @param {object} target The target object to merge into. This object will be modified.\n * @param {...object} sources The source objects to merge from.\n * @returns {object} The deeply merged object.\n */\nfunction deepMerge(target, ...sources) {\n  if (sources.length === 0) {\n    return target;\n  }\n\n  const source = sources.shift(); // Get the next source object\n\n  // Ensure target is an object and not null, otherwise return source or handle as non-mergeable\n  if (typeof target !== 'object' || target === null) {\n    return source; // If target is not an object, can't merge into it, just use source\n  }\n\n  // Ensure source is an object and not null\n  if (typeof source !== 'object' || source === null) {\n    return source; // If source is not an object, it's the final value for this path\n  }\n\n  // Handle arrays differently\n  if (Array.isArray(target) && Array.isArray(source)) {\n    // Concatenate arrays. For more complex logic (e.g., merging objects within arrays based on ID),\n    // this section would be more elaborate.\n    return [...target, ...source];\n  }\n\n  // If one is an array and the other is not, the source takes precedence.\n  // This avoids trying to merge an array into an object or vice-versa.\n  if (Array.isArray(target) !== Array.isArray(source)) {\n      return source;\n  }\n\n  // Iterate over properties of the source object\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      const targetValue = target[key];\n      const sourceValue = source[key];\n\n      if (typeof sourceValue === 'object' && sourceValue !== null && typeof targetValue === 'object' && targetValue !== null) {\n        // Both are objects/arrays, recurse\n        target[key] = deepMerge(targetValue, sourceValue);\n      } else {\n        // Otherwise, directly assign/overwrite\n        target[key] = sourceValue;\n      }\n    }\n  }\n\n  // Recursively merge the remaining sources\n  return deepMerge(target, ...sources);\n}",
    "explanation": "- **What it does:** This `deepMerge` function takes a `target` object and one or more `source` objects. It recursively traverses the properties of the source objects, merging them into the target. If a property exists in both target and source and both are objects (or arrays), it calls itself recursively to merge those nested structures. Otherwise, it directly assigns the source's value, effectively overwriting the target's value for primitive types or when types don't match (e.g., an object trying to merge with a string). Arrays are handled by concatenating their elements.\n\n- **Key lines:**\n  - **Lines 10-16:** Handles base cases where either target or source is not an object or is null, preventing errors and providing a sensible return value for non-mergeable paths.\n  - **Lines 19-24:** Specifically handles array merging. If both are arrays, they are concatenated. If one is an array and the other isn't, the source array takes precedence. This avoids type mismatch errors during recursion.\n  - **Lines 31-34:** This is the core recursive step. It checks if both `targetValue` and `sourceValue` are objects (and not null). If so, it calls `deepMerge` again for that nested path, ensuring a deep merge.\n  - **Line 36:** For all other cases (primitives, or when one is an object and the other isn't after the array check), the `sourceValue` directly overwrites the `targetValue`.\n  - **Line 41:** The function processes additional `sources` arguments sequentially, ensuring all provided objects are merged in order of precedence.",
    "usage": "- **How to integrate:**\n  Simply copy-paste the `deepMerge` function into your JavaScript codebase. You can place it in a utility file (`utils.js`) and import it, or define it directly where needed.\n\n- **Example call:**\n  javascript\n  const defaultSettings = {\n    theme: {\n      primaryColor: '#007bff',\n      typography: {\n        fontSize: '16px',\n        fontFamily: 'Arial, sans-serif'\n      }\n    },\n    api: {\n      baseUrl: 'https://api.example.com/v1',\n      timeout: 5000\n    },\n    features: ['dark-mode', 'notifications']\n  };\n\n  const userSettings = {\n    theme: {\n      primaryColor: '#6f42c1',\n      typography: {\n        fontSize: '14px' // Override font size\n      }\n    },\n    api: {\n      timeout: 10000 // Override API timeout\n    },\n    features: ['notifications', 'analytics'] // Concatenate features\n  };\n\n  const finalSettings = deepMerge(defaultSettings, userSettings);\n\n  console.log(finalSettings);\n  /* Expected Output:\n  {\n    theme: {\n      primaryColor: '#6f42c1', // Overridden\n      typography: {\n        fontSize: '14px',     // Overridden\n        fontFamily: 'Arial, sans-serif' // Retained from default\n      }\n    },\n    api: {\n      baseUrl: 'https://api.example.com/v1', // Retained\n      timeout: 10000 // Overridden\n    },\n    features: ['dark-mode', 'notifications', 'notifications', 'analytics'] // Concatenated\n  }\n  */\n\n  const immutableMerge = deepMerge({}, defaultSettings, userSettings); // To create a new object\n  console.log(immutableMerge);\n  ",
    "references": "- [Stack Overflow: How to deep merge two Javascript objects?](https://stackoverflow.com/questions/27936772/how-to-deep-merge-two-javascript-objects) – A great resource for various approaches and considerations.\n- [Lodash `_.merge` documentation](https://lodash.com/docs/4.17.15#merge) – For a more robust, production-ready solution, libraries like Lodash offer battle-tested `_.merge` functionality, often with more advanced options (like custom array merging resolvers).\n- Related concept: `Object.assign()` and Spread Syntax (`{...obj}`), for understanding shallow vs. deep merges.",
    "tags_keywords": "javascript, object-manipulation, deep-merge, recursion, utility-function, configuration, immutable-data"
  }
}